# Nome do Workflow
name: Pipeline CI/CD - Desafio DevOps

# ---
# ETAPA DE GATILHO (TRIGGER)
# ---
# Define quando o workflow deve ser executado.
on:
  # Executa em todo 'push' para a branch 'main'
  push:
    branches: [ "main" ]
  # Também executa em 'pull requests' que têm a 'main' como destino
  pull_request:
    branches: [ "main" ]
  
  # Permite executar manualmente pela aba "Actions" do GitHub
  #workflow_dispatch:

# ---
# ETAPA DE DEFINIÇÃO DOS JOBS
# ---
jobs:
  # ------------------------------------
  # JOB 1: BUILD (Construir Imagem Docker)
  # ------------------------------------
  build:
    name: Construir Imagem Docker
    runs-on: ubuntu-latest
    # Este job roda em PARALELO com o job 'test'

    steps:
      # 1. Baixa o código
      - name: Checkout do código
        uses: actions/checkout@v4

    # 2. Configura o ambiente Python
      - name: Configurar Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          cache: 'pip' # Adiciona cache para as dependências

    # 3. Instala as dependências (do seu arquivo requirements.txt)
      - name: Instalar dependências
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      # 2. Configura o QEMU (necessário para builds multi-plataforma)
      # - name: Set up QEMU
      #   uses: docker/setup-qemu-action@v3

      # 3. Configura o Docker Buildx (builder moderno do Docker)
      # - name: Set up Docker Buildx
      #   uses: docker/setup-buildx-action@v3

      # 4. (Opcional) Login no Docker Hub ou GitHub Container Registry
      # Descomente as linhas abaixo se quiser publicar a imagem
      # - name: Login to Docker Hub
      #   uses: docker/login-action@v3
      #   with:
      #     username: ${{ secrets.DOCKERHUB_USERNAME }}
      #     password: ${{ secrets.DOCKERHUB_TOKEN }}

      # 5. Constrói a imagem Docker
      # Este step constrói a imagem e a tagueia com o SHA do commit
      # O '--push=false' é o padrão, apenas constrói localmente na VM.
      - name: Build da imagem Docker
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: false # Mude para 'true' se quiser publicar no registry
          tags: minha-api:${{ github.sha }}

  # ------------------------------------
  # JOB 2: TESTE (Executar Testes Unitários)
  # ------------------------------------
  test:
    name: Rodar Testes Unitários
    # Define a máquina virtual onde o job será executado
    runs-on: ubuntu-latest

    steps:
      # 1. Baixa o código do repositório para a VM
      - name: Checkout do código
        uses: actions/checkout@v4
          
      # 4. Executa os testes unitários (baseado no seu test_app.py)
      - name: Rodar testes com unittest
        run: python -m unittest test_app.py

  # ------------------------------------
  # JOB 3: DEPLOY (Simulação de Deploy)
  # ------------------------------------
  deploy:
    name: Simular Deploy
    runs-on: ubuntu-latest
    
    # --- CONTROLE SEQUENCIAL ---
    # 'needs' garante que este job SÓ execute se os jobs 'test' e 'build'
    # terminarem com sucesso.
    needs: [test, build]

    steps:
      - name: Simulação de deploy
        run: |
          echo "Iniciando processo de deploy..."
          echo "Buscando o artefato do build (imagem Docker)..."
          echo "Tag da imagem: minha-api:${{ github.sha }}"
          echo "Deploy em ambiente de 'staging'..."
          sleep 10 # Simula tempo de deploy
          echo "Deploy (simulado) concluído com sucesso!"